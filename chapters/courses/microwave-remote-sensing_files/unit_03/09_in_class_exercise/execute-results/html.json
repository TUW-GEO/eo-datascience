{
  "hash": "5d0419be2a66c81fce098311208693a5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Phase Unwrapping\njupyter: microwave-remote-sensing\n---\n\n\n\nThe goal of this notebook is to read an interferogram image (i.e., 2-D array of phase values) and unwrap it. Phase unwrapping is a critical process in interferometry, which involves recovering unambiguous phase data from the interferogram.\n\nA SAR interferogram represents the phase difference between two radar acquisitions (i.e., two SLC images). The phase difference is usually wrapped within a range of 0 to 2π, because the phase is inherently cyclical. When the true phase difference exceeds 2π, it gets \"wrapped\" into this range, creating a discontinuous phase signal. Phase unwrapping refers to the process of reconstructing the continuous phase field from the wrapped phase data.\n\nUnwrapping an interferogram is essential for extracting correct information contained in the phase such as surface topography and earth surface deformations.\n\nThere are many approaches that tried to solve the unwrapping problem, tackling challenging scenarios involving noise or large phase discontinuities. Here we present the Network-flow Algorithm for phase unwrapping (C. W. Chen and H. A. Zebker, 2000), which is implemented in the `snaphu` package.\n\n## Loading Data\nThe data is stored on the Jupyterhub server, so we need to load it using their respective paths.\nIn this notebook we will use the resulting wrapped interferogram from notebook \"Interferograms\", but we need to process it in the radar geometry in order to unwrap it (while in notebook \"Interferograms\" we end the whole process by performing the geocoding, just for better visualization purposes).\n\n::: {#00732a95 .cell execution_count=2}\n``` {.python .cell-code}\nimport cmcrameri as cmc  # noqa: F401\nimport intake\nimport matplotlib.patches as patches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport snaphu\nimport xarray as xr\nfrom IPython.display import clear_output\n```\n:::\n\n\n::: {#1000b954 .cell execution_count=3}\n``` {.python .cell-code}\nuri = \"https://git.geo.tuwien.ac.at/public_projects/microwave-remote-sensing/-/raw/main/microwave-remote-sensing.yml\"\ncat = intake.open_catalog(uri)\nds = cat.complex.read().compute()\nds[\"cmplx\"] = ds[\"real\"] + ds[\"imag\"] * 1j\n```\n:::\n\n\n::: {#08dc9b5a .cell execution_count=4}\n``` {.python .cell-code}\n# Set cyclic and linear colormaps\ncmap_cyc = sns.color_palette(\"hls\", as_cmap=True)  # \"cmc.romaO\"\ncmap_lin = \"cmc.roma_r\"\ncmap_disp = \"cmc.vik\"\n\n# Create a mask for the areas which have no data\nmask = ds.phase.where(ds.phase == 0, True, False).astype(bool)\n```\n:::\n\n\nLet's start by displaying the interferogram that needs to be unwrapped. Recall that due to the Slant Range geometry and the satellite acquisition pass (ascending, in our case), the image appears north/south flipped (with respect to the geocoded image)!\n\n::: {#bf4aa0af .cell execution_count=5}\n``` {.python .cell-code}\n# Plot Phase Interferogram Image\nfig, axs = plt.subplots(figsize=(6, 6))\n\n(\n    ds.phase.where(mask)\n    .plot.imshow(cmap=cmap_cyc, zorder=1)\n    .axes.set_title(\"Phase Interferogram Image (Wrapped)\")\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n## Phase Unwrapping\n\nAs we will be doing the unwrapping multiple times in this notebook let's create a function that does the unwrapping for us on `xarray DataArray` objects.\nThe actual core function where the unwrapping is happening is `snaphu.unwrap_phase` from the `snaphu` package. This function needs a 2D numpy array as input, where each pixel value is a complex number.\nTherefore we have to convert the `xarray DataArray` to a 2D numpy array with complex values. We do that by combining the phase and intensity bands to a complex array.\nThe actual unwrapping is essentially an addition of the phase values, such that the values are continuous and not between $-\\pi$ and $\\pi$.\n\n![](https://forum.step.esa.int/uploads/default/original/3X/5/d/5d9d18e2a3121a4bb80cb93a8f62aed742e35fc2.png)\n\n*Figure 1: Illustration of how the unwrapping of the phase works. (Source: ESA)*.\n\n::: {#347ca786 .cell execution_count=6}\n``` {.python .cell-code}\ndef unwrap_array(\n    data: xr.DataArray,\n    complex_var: str = \"cmplx\",\n    ouput_var: str = \"unwrapped\",\n    mask: xr.DataArray = True,\n    coherence: xr.DataArray = None,\n    mask_nodata_value: int = 0,\n    coh_low_threshold: float = None,\n    coh_high_threshold: float = None,\n    nlooks=1.0,\n    cost=\"smooth\",\n    init=\"mcf\",\n    **kwargs,\n) -> xr.DataArray:\n    \"\"\"\n    Unwraps the phase data using the snaphu algorithm.\n\n    Parameters\n    ----------\n\n    data: xarray DataArray with complex numbers\n    complex_var: Name of the variable with the complex numbers\n    ouput_var: Name of the variable with the unwrapped phase\n    mask: xarray DataArray with mask values\n    coherence: xarray DataArray with coherence values (optional)\n    mask_nodata_value: Value of the no data pixels in the mask\n    coh_low_threshold: Lower threshold for the coherence values\n    coh_high_threshold: Higher threshold for the coherence values\n\n    Returns\n    ----------\n    xarray DataArray with the unwrapped phase\n    \"\"\"\n    # Get the complex data\n    data_arr = data[complex_var]\n\n    # Create a mask for areas with no data\n    if mask is True:\n        mask = (data_arr.real != mask_nodata_value).astype(bool)\n\n    # Apply coherence thresholds if provided\n    if coherence is not None:\n        if coh_low_threshold is not None:\n            coh_mask = (coherence >= coh_low_threshold).astype(bool)\n            mask = mask & coh_mask\n        if coh_high_threshold is not None:\n            coh_mask = (coherence <= coh_high_threshold).astype(bool)\n            mask = mask & coh_mask\n\n    # Apply the mask to the data\n    data_arr = data_arr.where(mask)\n\n    if coherence is None:\n        coherence = np.ones_like(data_arr.real)\n\n    # Unwrap the phase (already in complex form)\n    unw, _ = snaphu.unwrap(\n        data_arr,\n        coherence,\n        nlooks=nlooks,\n        cost=cost,\n        init=init,\n        mask=mask,\n        **kwargs,\n    )\n\n    # Clear the output to avoid printing the snaphu output\n    clear_output()\n\n    # Build xarray DataArray with the unwrapped phase\n    # unw_da = xr.DataArray(unw, coords=data.coords, dims=data.dims)\n    # data = data.to_dataset()\n    data[ouput_var] = ((\"y\", \"x\"), unw)\n\n    # Mask the unwrapped phase\n    # unw_da = unw_da.where(mask)\n    data[ouput_var] = data[ouput_var].where(mask)\n    return data\n```\n:::\n\n\n### Unwrapping on a Subset\n\nAs the original image is too large to unwrap in a reasonable time, we will unwrap a subset of the image. In this case, we will unwrap an area of 500x500 pixels.\n\n::: {#ff168cea .cell execution_count=7}\n``` {.python .cell-code}\n# Select a subset of the data\ndx, dy = 500, 500\nx0, y0 = 2800, 1700\n\n\ndef subsetting(ds, x0: int = 0, y0: int = 0, dx: int = 500, dy: int = 500):\n    return ds.isel(x=slice(x0, x0 + dx), y=slice(y0, y0 + dy))\n\n\n# Subsetting the data arrays\nsubset = subsetting(ds.where(mask), x0, y0, dx, dy)\n\n# Unwrap the subset\nsubset = unwrap_array(subset, complex_var=\"cmplx\", ouput_var=\"unwrapped\")\n```\n:::\n\n\nNow let's compare the wrapped and unwrapped phase images.\n\n::: {#5e9a55e8 .cell execution_count=8}\n``` {.python .cell-code}\nfig, axs = plt.subplots(1, 3, figsize=(14, 4))\n\n# Wrapped Phase\n\n(\n    subset.phase.plot.imshow(cmap=cmap_cyc, ax=axs[0]).axes.set_title(\n        \"Wrapped Phase of the Subset\"\n    )\n)\n\n# Unwrapped Phase\n(\n    subset.unwrapped.plot.imshow(\n        cmap=cmap_cyc, ax=axs[1], vmin=-80, vmax=80\n    ).axes.set_title(\"Unwrapped Phase of the Subset\")\n)\n\n# Subset inside the complete image\n(\n    ds.phase.where(mask)\n    .plot.imshow(cmap=cmap_cyc, zorder=1, ax=axs[2])\n    .axes.set_title(\"Complete Wrapped Phase Image\")\n)\n\nx_start = ds.phase.coords[\"x\"][x0].item()\ny_start = ds.phase.coords[\"y\"][y0].item()\nx_end = ds.phase.coords[\"x\"][x0 + dx].item()\ny_end = ds.phase.coords[\"y\"][y0 + dy].item()\n\nrect = patches.Rectangle(\n    (x_start, y_start),\n    x_end - x_start,\n    y_end - y_start,\n    linewidth=1,\n    edgecolor=\"r\",\n    facecolor=\"red\",\n    alpha=0.5,\n    label=\"Subset\",\n)\n\n# Add the rectangle to the plot\naxs[2].add_patch(rect)\naxs[2].legend()\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n### Unwrapping with coherence mask\nAdditionally, can we try to calculate the unwrapped image, where we are excluding pixels, where the coherence values are lower than a certain threshold. This is done by masking the coherence image with the threshold value and then unwrapping the phase image with the masked coherence image.\n\n::: {#653218ed .cell execution_count=9}\n``` {.python .cell-code}\nthreshold1 = 0.3\nsubset = unwrap_array(\n    subset,\n    coherence=subset.coh,\n    coh_low_threshold=threshold1,\n    complex_var=\"cmplx\",\n    ouput_var=\"unwrapped_coh\",\n)\n```\n:::\n\n\nLet's compare the unwrapped image with and without the coherence mask.\n\n::: {#ee99caed .cell execution_count=10}\n``` {.python .cell-code}\nfig, axs = plt.subplots(1, 2, figsize=(13, 5))\n(\n    subset.unwrapped_coh.plot.imshow(\n        cmap=cmap_cyc, ax=axs[0], vmin=-80, vmax=80\n    ).axes.set_title(f\"Unwrapped Phase with Coherence Threshold {threshold1}\")\n)\n\n(\n    subset.unwrapped.plot.imshow(\n        cmap=cmap_cyc, ax=axs[1], vmin=-80, vmax=80\n    ).axes.set_title(\"Unwrapped Phase without Coherence Threshold\")\n)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-10-output-1.png){}\n:::\n:::\n\n\nLet's see if another threshold value for the coherence mask gives better results.\n\n::: {#35956003 .cell execution_count=11}\n``` {.python .cell-code}\nthreshold2 = 0.5\nsubset = unwrap_array(\n    subset,\n    coherence=subset.coh,\n    coh_low_threshold=threshold2,\n    complex_var=\"cmplx\",\n    ouput_var=\"unwrapped_coh2\",\n)\n\nfig, axs = plt.subplots(1, 2, figsize=(13, 5))\n(\n    subset.unwrapped_coh2.plot.imshow(\n        cmap=cmap_cyc, ax=axs[0], vmin=-80, vmax=80\n    ).axes.set_title(\"Coherence Threshold 0.5\")\n)\n\n(\n    subset.unwrapped_coh.plot.imshow(\n        cmap=cmap_cyc, ax=axs[1], vmin=-80, vmax=80\n    ).axes.set_title(\"Coherence Threshold 0.3\")\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-11-output-1.png){}\n:::\n:::\n\n\nA higher coherence threshold means that only pixels with a coherence value greater than 0.5 will be used for phase unwrapping. This would result in an unwrapping process that is likely more stable, with reduced noise (invalid phase information in the proximity of the earthquake faults is discarded). However, an excessive coherence threshold might have significant gaps or missing information, especially in areas where motion or surface changes have occurred.\nThe choice of a coherence threshold depends on the balance you want to strike between the accuracy and coverage of the output unwrapped image.\n\nKeep in mind that in case of large displacements, such as the Ridgecrest earthquake, phase unwrapping can be problematic and lead to poor results: when the displacement is large, the phase difference becomes wrapped multiple times, leading to phase aliasing. In this case, the phase values become ambiguous, we cannot distinguish between multiple phase wraps, thus leading to incorrect results.\n\n## Applying an Equation for the Displacement Map\n\nFrom the unwrapped phase image (we will use the phase masked with a coherence threshold of 0.3) we can calculate the displacement map using the following equation:\n\n$\nd = - \\frac{\\lambda}{4 \\cdot \\pi} \\cdot \\Delta \\phi_d\n$\n\nwhere:\n- $\\lambda = 0.056$ for Sentinel-1\n- $\\Delta \\phi_d$ is the unwrapped image\n\nThis operation can be very useful for monitoring ground deformation.\n\n::: {#1aa5e98e .cell execution_count=12}\n``` {.python .cell-code}\ndef displacement(unw, lambda_val: float = 0.056) -> xr.DataArray:\n    \"\"\"\n    Calculates the displacement from the unwrapped phase\n\n    Parameters\n    ----------\n\n    unw: xarray DataArray with the unwrapped phase\n    unw: xr.DataArray\n    lambda_val: Wavelength of the radar signal\n    lambda_val: float\n\n    Returns\n    -------\n    xarray DataArray with the displacement\n    \"\"\"\n    disp = unw * -lambda_val / (4 * np.pi)\n    return disp\n\n\n# Calculate the displacement\ndisp_subset = displacement(subset.unwrapped_coh)\n```\n:::\n\n\n::: {#9e20abdc .cell execution_count=13}\n``` {.python .cell-code}\n# Plot the displacement map\n(\n    disp_subset.plot.imshow(\n        cmap=cmap_disp, cbar_kwargs={\"label\": \"Meters [m]\"}\n    ).axes.set_title(\"Displacement Map of the Subset\")\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n## Coarsen Approach\n\nAs the whole data is too large and the processing time already exceeds 20 minutes when using an image with 4000x4000 pixels, we can coarsen the image so that we can unwrap and compute the displacement for the whole scene.\n\n::: {#71028a49 .cell execution_count=14}\n``` {.python .cell-code}\nkernel_size = 3\nlowres = ds.coarsen(x=kernel_size, y=kernel_size, boundary=\"trim\").median()\n```\n:::\n\n\n::: {#6dcc26ed .cell execution_count=15}\n``` {.python .cell-code}\nlowres = unwrap_array(\n    lowres,\n    ntiles=(20, 30),\n    tile_overlap=10,\n    coherence=lowres.coh,\n    coh_low_threshold=0.3,\n    complex_var=\"cmplx\",\n    ouput_var=\"unwrapped\",\n)\n```\n:::\n\n\nWe can now plot the unwrapped image of the low resolution image.\n\n::: {#c271e5ab .cell execution_count=16}\n``` {.python .cell-code}\n# Plot the unwrapped phase\n(\n    lowres.unwrapped.plot.imshow(cmap=cmap_cyc).axes.set_title(\n        \"Unwrapped Phase entire scene (coarsened)\"\n    )\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-16-output-1.png){}\n:::\n:::\n\n\nWe can also now calculate the displacement map and compare them.\n\n::: {#0bb9340b .cell execution_count=17}\n``` {.python .cell-code}\nlowres_disp = displacement(lowres.unwrapped)\n\n# Plot the displacement map\n(\n    lowres_disp.plot.imshow(\n        cmap=cmap_disp, cbar_kwargs={\"label\": \"Meters [m]\"}\n    ).axes.set_title(\"Displacement Map entire scene (coarse resolution)\")\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-17-output-1.png){}\n:::\n:::\n\n\nPlot a summary of the previous plots:\n\n::: {#f154b3ca .cell execution_count=18}\n``` {.python .cell-code}\n# Plot summary of previous plots\nfig, axs = plt.subplots(2, 2, figsize=(12, 10))\nax = axs.ravel()\n\n(\n    subset.unwrapped_coh.plot.imshow(\n        cmap=cmap_cyc, ax=ax[0], vmin=-80, vmax=80\n    ).axes.set_title(\"Unwrapped Phase of the subset with Coherence Threshold 0.3\")\n)\n\n(\n    disp_subset.plot.imshow(\n        cmap=cmap_disp, ax=ax[1], cbar_kwargs={\"label\": \"Meters [m]\"}\n    ).axes.set_title(\"Displacement Map of the Subset\")\n)\n\n(\n    lowres.unwrapped.plot.imshow(cmap=cmap_cyc, ax=ax[2]).axes.set_title(\n        \"Unwrapped Phase of the entire scene with Coherence Threshold 0.3 (coarsened)\"\n    )\n)\n\n(\n    lowres_disp.plot.imshow(\n        cmap=cmap_disp, ax=ax[3], cbar_kwargs={\"label\": \"Meters [m]\"}\n    ).axes.set_title(\"Displacement Map entire scene (coarse resolution)\")\n)\n\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_in_class_exercise_files/figure-html/cell-18-output-1.png){}\n:::\n:::\n\n\nIn the following animation, we can capture the 3D displacement caused by the Ridgecrest quake by observing the after and before elevation model.\n\n![](../../images/ridgecrest.gif)\n*Credits: NASA*\n\n",
    "supporting": [
      "09_in_class_exercise_files"
    ],
    "filters": [],
    "includes": {}
  }
}